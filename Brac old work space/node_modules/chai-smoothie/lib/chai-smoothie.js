"use strict";
var protractor_1 = require('protractor');
function protractorChai(chai, utils) {
    function ensureAssertingOn(type, assertion) {
        var is = function (expected, candidate) { return candidate instanceof expected; }, typeOf = function (object) { return !!object && object.constructor && object.constructor.name; }, notEmpty = function (value) { return !!value ? value : ''; };
        if (!is(type, assertion._obj)) {
            var message = notEmpty(typeOf(assertion._obj)) + " " + utils.inspect(assertion._obj) + " is not of type " + type.name;
            throw new TypeError(message.trim());
        }
        return assertion;
    }
    function addBooleanProperty(property) {
        var methodNameFrom = function (propertyName) { return ("is" + propertyName.charAt(0).toUpperCase() + propertyName.slice(1)); }, method = methodNameFrom(property);
        chai.Assertion.addProperty(property, function () {
            var _this = this;
            var assertion = ensureAssertingOn(protractor_1.ElementFinder, this);
            var locator = assertion._obj.locator();
            return assertion._obj[method]().then(function (state) { return _this.assert(state, "Expected the element located " + locator + " to be " + property + ", but it's not.", "Expected the element located " + locator + " not to be " + property + ", yet it is."); });
        });
    }
    function supportChaiAsPromised() {
        function isOfInterest(obj) {
            return !!obj && obj instanceof protractor_1.ElementFinder && !obj.then;
        }
        chai.Assertion.overwriteProperty('eventually', function (_super) {
            return function () {
                var subject = this._obj;
                if (isOfInterest(subject)) {
                    var protractorAssertion = new chai.Assertion(subject); // tslint:disable-line
                    utils.transferFlags(this, protractorAssertion, false); // false means don't transfer `object` flag
                }
                else {
                    _super.call(this);
                }
            };
        });
    }
    addBooleanProperty('displayed');
    addBooleanProperty('present');
    addBooleanProperty('enabled');
    addBooleanProperty('selected');
    supportChaiAsPromised();
    chai.Assertion.addMethod('text', function (expected) {
        var _this = this;
        var assertion = ensureAssertingOn(protractor_1.ElementFinder, this);
        var locator = assertion._obj.locator();
        if (utils.flag(this, 'contains')) {
            return assertion._obj.getText().then(function (text) { return _this.assert(text.trim().includes(expected), "Expected the element located " + locator + " with text '" + text + "' to contain '" + expected + "'.", "Expected the element located " + locator + " with text '" + text + "' to not contain '" + expected + "'."); });
        }
        else {
            return assertion._obj.getText().then(function (text) { return _this.assert(text.trim() === expected, "Expected the element located " + locator + " with text '" + text + "' to have '" + expected + "'.", "Expected the element located " + locator + " with text '" + text + "' to not have '" + expected + "'."); });
        }
    });
}
module.exports = protractorChai;

//# sourceMappingURL=chai-smoothie.js.map
